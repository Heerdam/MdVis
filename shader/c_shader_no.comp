#version 430 core

#define M_PI 3.141592653589
#define M_PI_2 6.2831853071

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(location = 1) uniform int atomCount; //#atoms
layout(location = 2) uniform int maxSteps;
layout(location = 3) uniform float t; 
layout(location = 7) uniform float frac;

layout(location = 4) uniform int sphere_vertices;
layout(location = 5) uniform float radius;

layout(location = 6) uniform vec4 color;

layout (location = 8) uniform vec3 dims;

layout(std430, binding = 1) buffer traj {
	float traj_data[];
};

layout(std430, binding = 2) readonly buffer sphere {
	float sphere_data[];
};

layout(std430, binding = 3) writeonly buffer vertex {
	float ver_data[];
};

layout(std430, binding = 4) readonly buffer weights {
	float w_data[];
};

void main() {

	const int currentStep = int(float(maxSteps) * t) % maxSteps;
	const int index = int(gl_GlobalInvocationID.x);
	//traj offset
	const int offset_t = 3 * index + currentStep * atomCount * 3;
	//offset to the sphere we are currently building
	const uint verIndex = index * sphere_vertices * 3;

	//build spheres at given centre
	const vec3 cntr = vec3(traj_data[offset_t], traj_data[offset_t + 1], traj_data[offset_t + 2]);

	for(int i = 0; i < sphere_vertices; ++i) {	
		//pos
		ver_data[verIndex + 3*i] = cntr.x + sphere_data[3*i] * radius;
		ver_data[verIndex + 3*i + 1] = cntr.y + sphere_data[3*i+1] * radius;
		ver_data[verIndex + 3*i + 2] = cntr.z + sphere_data[3*i+2] * radius;		
	}
	
}

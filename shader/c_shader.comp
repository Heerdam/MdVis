#version 460 core

#define M_PI 3.141592653589
#define M_PI_2 6.2831853071

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(location = 1) uniform unsigned int atomCount; //#atoms
layout(location = 2) uniform int maxSteps;
layout(location = 3) uniform float t; 
layout(location = 7) uniform float frac;

layout(location = 4) uniform unsigned int sphere_vertices;
layout(location = 5) uniform float radius;

layout(location = 6) uniform vec4 color;

layout(std430, binding = 1) readonly buffer traj {
	float traj_data[];
};

layout(std430, binding = 2) readonly buffer sphere {
	float sphere_data[];
};

layout(std430, binding = 3) writeonly buffer vertex {
	float ver_data[];
};

layout(std430, binding = 4) readonly buffer weights {
	float w_data[];
};

void main() {

	const int currentStep = int(float(maxSteps) * t) % maxSteps;
	const int offset = int(currentStep) * int(atomCount) * 3;
	const uint index = gl_GlobalInvocationID.x;
	const int vertexSize = 3;
	const uint verIndex = index * sphere_vertices * vertexSize;

	float h = t - currentStep*frac;
	uint idx = 12* index + currentStep * atomCount * 12;

	vec3 traj = vec3(w_data[idx], w_data[idx+1], w_data[idx+2]);
	vec3 m_a = vec3(w_data[idx+3], w_data[idx+4], w_data[idx+5]);
	vec3 m_b = vec3(w_data[idx+6], w_data[idx+7], w_data[idx+8]);
	vec3 m_c = vec3(w_data[idx+9], w_data[idx+10], w_data[idx+11]);

	vec3 pos = ((m_a * h + m_b) * h + m_c) * h + traj;

	for(int i = 0; i < sphere_vertices; ++i) {		
		//pos
		ver_data[verIndex + i*vertexSize] = pos.x + sphere_data[3*i] * radius;
		ver_data[verIndex + i*vertexSize + 1] = pos.y + sphere_data[3*i+1] * radius;
		ver_data[verIndex + i*vertexSize + 2] = pos.z + sphere_data[3*i+2] * radius;		
	}
	
}

#version 460 core

#define M_PI 3.141592653589
#define M_PI_2 6.2831853071

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(location = 1) uniform unsigned int atomCount; //#atoms
layout(location = 2) uniform unsigned int maxSteps;
layout(location = 3) uniform float t; //current t

layout(location = 4) uniform unsigned int sphere_vertices;
layout(location = 5) uniform float radius;

layout(location = 6) uniform vec4 color;

layout(std430, binding = 1) readonly buffer traj {
	float traj_data[];
};

layout(std430, binding = 2) readonly buffer sphere {
	float sphere_data[];
};

layout(std430, binding = 3) writeonly buffer vertex {
	float ver_data[];
};

void main() {


	const int currentStep = int(float(maxSteps) * t);
	const int offset = int(currentStep) * int(atomCount);
	const uint index = gl_LocalInvocationIndex;
	const uint verIndex = index * sphere_vertices * 10;

	//build spheres at given centre
	const vec3 cntr = vec3(traj_data[index], traj_data[index + 1], traj_data[index + 2]);

	for(int i = 0; i < sphere_vertices; ++i) {		
		//pos
		ver_data[verIndex + i] = cntr.x + sphere_data[3*i];
		ver_data[verIndex + i + 1] = cntr.y + sphere_data[3*i+1];
		ver_data[verIndex + i + 2] = cntr.z + sphere_data[3*i+2];
		//nrm
		ver_data[verIndex + i + 3] = sphere_data[3*i];
		ver_data[verIndex + i + 4] = sphere_data[3*i+1];
		ver_data[verIndex + i + 5] = sphere_data[3*i+2];
		//clr
		ver_data[verIndex + i + 6] = color.r;
		ver_data[verIndex + i + 7] = color.g;
		ver_data[verIndex + i + 8] = color.b;
		ver_data[verIndex + i + 9] = color.a;
	}
	
}
